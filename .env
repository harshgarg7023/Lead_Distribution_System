#!/usr/bin/env python3
"""
Single-file Matching Service (FastAPI + Background Workers)
- Wraps the Confidence-Weighted Hybrid + Fairness Fallback matcher
- Minimal in-memory storage for Phase-1 prototyping
- Includes background loops for:
    * lead assignment processor (≈ every 5s)
    * SLA monitor & reassignment (every 10 min)

Run:
    uvicorn matching_service:app --host 0.0.0.0 --port 8000 --reload

API:
  GET  /healthz
  POST /v1/partners           -> create/update a partner
  GET  /v1/partners           -> list partners
  POST /v1/leads              -> ingest a lead (push to queue)
  GET  /v1/leads/{lead_id}    -> fetch a lead
  POST /v1/leads/{lead_id}/assign -> trigger assignment immediately

Note: Replace stubs for geocoding and Google Sheets ingestion in production.
"""
from __future__ import annotations

import asyncio
import math
import random
import re
import time
import uuid
from dataclasses import dataclass, field, asdict
from datetime import datetime, timedelta
from typing import List, Optional, Tuple, Dict, Any

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field

# =============================
# Config / Constants
# =============================
SLA_RECENT_ACTIVITY_DAYS = 30
STANDBY_COUNT = 2
MIN_ACCEPTABLE_SCORE = 40.0
DEFAULT_CAP_KM = 10.0
COOLDOWN_MINUTES_UNKNOWN = 15
SLA_FIRST_ACTION_HOURS = 4

ASSIGNMENT_PROCESSOR_INTERVAL_SEC = 5
SLA_MONITOR_INTERVAL_SEC = 10 * 60

# =============================
# Data Models
# =============================
@dataclass
class Lead:
    id: str
    phone_number: Optional[str] = None
    vehicle_number: Optional[str] = None
    address: Optional[str] = None

    # Enriched fields
    geo: Optional[Tuple[float, float]] = None  # A1
    city: Optional[str] = None
    state: Optional[str] = None
    rto_geo: Optional[Tuple[float, float]] = None  # A3
    rto_city: Optional[str] = None
    rto_state: Optional[str] = None
    confidence: str = "A4"  # A1, A2, A3, A4

    status: str = "New"  # New/Accepted/etc. (kept simple here)
    created_at: datetime = field(default_factory=lambda: datetime.utcnow())
    updated_at: datetime = field(default_factory=lambda: datetime.utcnow())


@dataclass
class Partner:
    id: str
    name: str
    lat: Optional[float] = None
    lng: Optional[float] = None
    city: Optional[str] = None
    state: Optional[str] = None
    service_radius_km: Optional[float] = None

    app_installed: bool = True
    is_qualified: bool = True
    last_active_at: datetime = field(default_factory=lambda: datetime.utcnow())

    max_concurrent_open_leads: int = 10
    active_assigned_count: int = 0

    conv_rate_30d: float = 0.0  # 0..1
    strikes_7d: int = 0

    # For fairness fallback & quotas
    weekly_quota_target: int = 10
    weekly_assigned_count: int = 0
    last_unknown_location_assigned_at: Optional[datetime] = None

    def cap_km(self) -> float:
        return float(self.service_radius_km) if self.service_radius_km else DEFAULT_CAP_KM


@dataclass
class Assignment:
    lead_id: str
    partner_id: str
    is_active: bool = True
    assigned_at: datetime = field(default_factory=lambda: datetime.utcnow())
    notification_sent_at: Optional[datetime] = None
    response_at: Optional[datetime] = None
    response_status: Optional[str] = None
    reassigned_reason: Optional[str] = None
    queue_rank: Optional[int] = None


# =============================
# RTO Lookup (minimal)
# =============================
RTO_MAP: Dict[str, Dict[str, Any]] = {
    "MH01": {"city": "Mumbai", "state": "Maharashtra", "geo": (19.0760, 72.8777)},
    "MH12": {"city": "Pune", "state": "Maharashtra", "geo": (18.5204, 73.8567)},
    "DL01": {"city": "Delhi", "state": "Delhi", "geo": (28.6139, 77.2090)},
    "KA01": {"city": "Bengaluru", "state": "Karnataka", "geo": (12.9716, 77.5946)},
    "TN01": {"city": "Chennai", "state": "Tamil Nadu", "geo": (13.0827, 80.2707)},
}
RTO_REGEX = re.compile(r"^([A-Z]{2})\s*(\d{1,2})")

# =============================
# In-memory Stores (replace with DB in prod)
# =============================
PARTNERS: Dict[str, Partner] = {}
LEADS: Dict[str, Lead] = {}
ASSIGNMENTS: List[Assignment] = []

# work queue for new leads to match
LEAD_QUEUE: asyncio.Queue[str] = asyncio.Queue()

# =============================
# Utilities
# =============================

def now_utc() -> datetime:
    return datetime.utcnow()


def geo_distance_km(a: Tuple[float, float], b: Tuple[float, float]) -> float:
    import math
    lat1, lon1 = a
    lat2, lon2 = b
    R = 6371.0
    phi1 = math.radians(lat1)
    phi2 = math.radians(lat2)
    dphi = math.radians(lat2 - lat1)
    dlambda = math.radians(lon2 - lon1)
    x = math.sin(dphi / 2) ** 2 + math.cos(phi1) * math.cos(phi2) * math.sin(dlambda / 2) ** 2
    return 2 * R * math.asin(math.sqrt(x))


def norm_name(s: Optional[str]) -> Optional[str]:
    if not s:
        return None
    import re
    return re.sub(r"[^a-z]", "", s.strip().lower()) or None


def fuzzy_equal(a: Optional[str], b: Optional[str], max_dist: int = 2) -> bool:
    a = norm_name(a)
    b = norm_name(b)
    if not a or not b:
        return False
    if a == b:
        return True
    if abs(len(a) - len(b)) > max_dist:
        return False
    # Levenshtein
    dp_prev = list(range(len(b) + 1))
    for i, ca in enumerate(a, 1):
        dp_cur = [i]
        for j, cb in enumerate(b, 1):
            cost = 0 if ca == cb else 1
            dp_cur.append(min(
                dp_cur[-1] + 1,
                dp_prev[j] + 1,
                dp_prev[j-1] + cost
            ))
        dp_prev = dp_cur
    return dp_prev[-1] <= max_dist


# =============================
# Enrichment (A1/A2/A3/A4)
# =============================

def can_geocode(address: Optional[str]) -> bool:
    return False  # stub; wire real geocoder later


def geocode(address: str):
    return None


def reverse_geocode_city_state(geo):
    return None, None


def city_or_state_in_text(address: Optional[str]) -> bool:
    return bool(address and address.strip())


def parse_city_state(address: Optional[str]):
    if not address:
        return None, None
    tokens = [t.strip() for t in address.split(',') if t.strip()]
    if not tokens:
        return None, None
    city = tokens[-2] if len(tokens) >= 2 else tokens[-1]
    state = tokens[-1] if len(tokens) >= 2 else None
    return city, state


def is_valid_vehicle(vehicle_number: Optional[str]) -> bool:
    if not vehicle_number:
        return False
    v = vehicle_number.strip().upper().replace(" ", "")
    return bool(re.match(r"^[A-Z]{2}\d{1,2}[A-Z]{0,3}\d{1,4}$", v))


def parse_rto_code(vehicle_number: str) -> Optional[str]:
    v = vehicle_number.strip().upper().replace(" ", "")
    m = RTO_REGEX.match(v)
    if not m:
        return None
    return f"{m.group(1)}{m.group(2)}"


def enrich_lead_location(lead: Lead) -> Lead:
    if can_geocode(lead.address):
        geo = geocode(lead.address)
        if geo:
            lead.geo = geo
            c, s = reverse_geocode_city_state(geo)
            lead.city = lead.city or c
            lead.state = lead.state or s
            lead.confidence = "A1"
            return lead

    if city_or_state_in_text(lead.address):
        c, s = parse_city_state(lead.address)
        lead.city = lead.city or c
        lead.state = lead.state or s
        lead.confidence = "A2" if (lead.city or lead.state) else "A4"

    if is_valid_vehicle(lead.vehicle_number):
        code = parse_rto_code(lead.vehicle_number)
        if code and code in RTO_MAP:
            info = RTO_MAP[code]
            lead.rto_geo = info.get("geo")
            lead.rto_city = info.get("city")
            lead.rto_state = info.get("state")
            if lead.confidence == "A4":
                lead.confidence = "A3"
    return lead


# =============================
# Eligibility & Scoring
# =============================

def eligible_partners(now: datetime) -> List[Partner]:
    cutoff = now - timedelta(days=SLA_RECENT_ACTIVITY_DAYS)
    return [
        p for p in PARTNERS.values()
        if p.app_installed and p.is_qualified and p.last_active_at >= cutoff
        and p.active_assigned_count < p.max_concurrent_open_leads
    ]


def weight_by_confidence(conf: str) -> float:
    return {"A1": 1.0, "A2": 0.6, "A3": 0.5}.get(conf, 0.0)


def best_distance_km(lead: Lead, partner: Partner) -> float:
    distances: List[float] = []
    if lead.geo and partner.lat is not None and partner.lng is not None:
        distances.append(geo_distance_km(lead.geo, (partner.lat, partner.lng)))
    if lead.rto_geo and partner.lat is not None and partner.lng is not None:
        distances.append(geo_distance_km(lead.rto_geo, (partner.lat, partner.lng)))
    return min(distances) if distances else math.inf


def city_match(lead: Lead, partner: Partner) -> bool:
    return fuzzy_equal(lead.city or lead.rto_city, partner.city)


def quality_bucket(partner: Partner) -> float:
    if partner.conv_rate_30d > 0.12:
        return 1.0
    if partner.conv_rate_30d >= 0.05:
        return 0.5
    return 0.0


def activity_bucket(partner: Partner, now: datetime) -> float:
    delta = now - partner.last_active_at
    if delta <= timedelta(hours=24):
        return 1.0
    if delta <= timedelta(days=7):
        return 0.6
    return 0.3


def load_ratio(partner: Partner) -> float:
    return partner.active_assigned_count / max(1, partner.max_concurrent_open_leads)


def jitter_small() -> float:
    return random.uniform(0.0, 2.0)


def score_partner(lead: Lead, partner: Partner, now: datetime) -> float:
    w_geo = weight_by_confidence(lead.confidence)
    dist = best_distance_km(lead, partner)
    cap = partner.cap_km()

    distance_util = 0.0
    if dist != math.inf:
        distance_util = 100.0 * w_geo * (1.0 - min(dist / cap, 1.0))

    city_bonus = 25.0 * (1.0 if city_match(lead, partner) else 0.0)
    qual_bonus = 20.0 * quality_bucket(partner)
    act_bonus = 15.0 * activity_bucket(partner, now)

    strike_pen = 10.0 * float(partner.strikes_7d)
    load_pen = 15.0 * load_ratio(partner)

    return distance_util + city_bonus + qual_bonus + act_bonus - strike_pen - load_pen + jitter_small()


# =============================
# Matching & Fallback
# =============================

def get_prior_partners_for_lead(lead_id: str) -> List[str]:
    return [a.partner_id for a in ASSIGNMENTS if a.lead_id == lead_id]


def is_remote_or_large_radius(partner: Partner) -> bool:
    radius = partner.cap_km()
    return radius >= 15.0 or not partner.city or not partner.state


def last_unknown_lead_assigned_minutes_ago(partner: Partner, now: datetime) -> float:
    if not partner.last_unknown_location_assigned_at:
        return float("inf")
    return (now - partner.last_unknown_location_assigned_at).total_seconds() / 60.0


def weekly_quota_deficit_percent(partner: Partner) -> float:
    target = max(1, partner.weekly_quota_target)
    deficit = max(0, target - partner.weekly_assigned_count)
    return min(100.0, 100.0 * deficit / target)


def fairness_fallback(lead: Lead, candidates: List[Partner], now: datetime):
    pool = [
        p for p in candidates
        if is_remote_or_large_radius(p) and last_unknown_lead_assigned_minutes_ago(p, now) >= COOLDOWN_MINUTES_UNKNOWN
    ]
    if not pool:
        return None, []

    scored = []
    for p in pool:
        quota_deficit = weekly_quota_deficit_percent(p)
        s = (
            50.0 * (quota_deficit / 100.0)
            + 25.0 * quality_bucket(p)
            + 15.0 * activity_bucket(p, now)
            - 10.0 * float(p.strikes_7d)
            - 15.0 * load_ratio(p)
            + jitter_small()
        )
        scored.append((p, s))

    scored.sort(key=lambda x: x[1], reverse=True)
    primary = scored[0][0]
    standby = [p for p, _ in scored[1:1 + STANDBY_COUNT]]

    primary.last_unknown_location_assigned_at = now
    return primary, standby


def match_partner(lead: Lead, now: Optional[datetime] = None):
    now = now or now_utc()
    enrich_lead_location(lead)

    candidates = eligible_partners(now)
    # Exclude previous partners used for this lead
    prior = set(get_prior_partners_for_lead(lead.id))
    candidates = [p for p in candidates if p.id not in prior]

    scored = [(p, score_partner(lead, p, now)) for p in candidates]
    scored.sort(key=lambda x: x[1], reverse=True)

    if not scored or scored[0][1] < MIN_ACCEPTABLE_SCORE:
        return fairness_fallback(lead, candidates, now)

    primary = scored[0][0]
    standby = [p for p, _ in scored[1:1 + STANDBY_COUNT]]
    return primary, standby


# =============================
# Assignment operations
# =============================

def create_assignment(lead_id: str, partner_id: str, is_active: bool = True, queue_rank: Optional[int] = None) -> Assignment:
    a = Assignment(lead_id=lead_id, partner_id=partner_id, is_active=is_active, queue_rank=queue_rank)
    ASSIGNMENTS.append(a)
    if is_active:
        PARTNERS[partner_id].active_assigned_count += 1
        PARTNERS[partner_id].weekly_assigned_count += 1
    return a


def deactivate_assignment(lead_id: str, partner_id: str, reason: str):
    for a in ASSIGNMENTS:
        if a.lead_id == lead_id and a.partner_id == partner_id and a.is_active:
            a.is_active = False
            a.reassigned_reason = reason
            PARTNERS[partner_id].active_assigned_count = max(0, PARTNERS[partner_id].active_assigned_count - 1)
            return a
    return None


def active_assignment_for_lead(lead_id: str) -> Optional[Assignment]:
    for a in sorted([x for x in ASSIGNMENTS if x.lead_id == lead_id and x.is_active], key=lambda z: z.assigned_at, reverse=True):
        return a
    return None


# =============================
# Background Workers
# =============================
async def assignment_processor_loop():
    while True:
        try:
            lead_id = await LEAD_QUEUE.get()
            lead = LEADS.get(lead_id)
            if not lead:
                continue
            primary, standby = match_partner(lead)
            if not primary:
                # No partner for now; requeue after small delay
                await asyncio.sleep(2)
                await LEAD_QUEUE.put(lead_id)
                continue

            # Create assignments
            create_assignment(lead.id, primary.id, is_active=True, queue_rank=1)
            if standby:
                for i, p in enumerate(standby, start=2):
                    create_assignment(lead.id, p.id, is_active=False, queue_rank=i)
            # Simulate push notification timestamp
            a = active_assignment_for_lead(lead.id)
            if a:
                a.notification_sent_at = now_utc()
        except Exception as e:
            # In production, log this
            await asyncio.sleep(1)
        finally:
            await asyncio.sleep(0)  # yield


async def sla_monitor_loop():
    while True:
        try:
            now = now_utc()
            for a in list(ASSIGNMENTS):
                if not a.is_active:
                    continue
                if a.response_at is not None:
                    continue
                if not a.notification_sent_at:
                    continue
                if (now - a.notification_sent_at) >= timedelta(hours=SLA_FIRST_ACTION_HOURS):
                    # SLA breach → reassign to standby or rematch
                    partner_id = a.partner_id
                    deactivate_assignment(a.lead_id, partner_id, reason='SLA_BREACH')
                    PARTNERS[partner_id].strikes_7d += 1

                    # Try standby
                    standbys = [x for x in ASSIGNMENTS if x.lead_id == a.lead_id and not x.is_active]
                    standbys.sort(key=lambda z: z.queue_rank or 99)
                    if standbys:
                        nxt = standbys[0]
                        nxt.is_active = True
                        nxt.assigned_at = now
                        nxt.notification_sent_at = now
                        PARTNERS[nxt.partner_id].active_assigned_count += 1
                    else:
                        # Re-queue lead for fresh matching excluding previous partners
                        await LEAD_QUEUE.put(a.lead_id)
        except Exception:
            await asyncio.sleep(1)
        finally:
            await asyncio.sleep(SLA_MONITOR_INTERVAL_SEC)


# =============================
# FastAPI App & Schemas
# =============================
app = FastAPI(title="Matching Service", version="1.0")


class PartnerIn(BaseModel):
    id: Optional[str] = None
    name: str
    lat: Optional[float] = None
    lng: Optional[float] = None
    city: Optional[str] = None
    state: Optional[str] = None
    service_radius_km: Optional[float] = None
    app_installed: bool = True
    is_qualified: bool = True
    last_active_at: Optional[datetime] = None
    max_concurrent_open_leads: int = 10
    active_assigned_count: int = 0
    conv_rate_30d: float = 0.0
    strikes_7d: int = 0
    weekly_quota_target: int = 10
    weekly_assigned_count: int = 0


class LeadIn(BaseModel):
    id: Optional[str] = None
    phone_number: Optional[str] = None
    vehicle_number: Optional[str] = None
    address: Optional[str] = None


@app.on_event("startup")
async def startup_event():
    # seed a few partners for quick testing
    if not PARTNERS:
        PARTNERS["p1"] = Partner(id="p1", name="Alpha Motors", lat=19.08, lng=72.88, city="Mumbai", state="Maharashtra", service_radius_km=12, conv_rate_30d=0.08, active_assigned_count=0)
        PARTNERS["p2"] = Partner(id="p2", name="Beta Auto", lat=18.52, lng=73.86, city="Pune", state="Maharashtra", service_radius_km=10, conv_rate_30d=0.15, active_assigned_count=0)
        PARTNERS["p3"] = Partner(id="p3", name="Gamma Wheels", lat=28.61, lng=77.21, city="Delhi", state="Delhi", service_radius_km=20, conv_rate_30d=0.05, active_assigned_count=0)
        PARTNERS["p4"] = Partner(id="p4", name="Delta Cars", service_radius_km=25, conv_rate_30d=0.03, active_assigned_count=0)

    # start background workers
    asyncio.create_task(assignment_processor_loop())
    asyncio.create_task(sla_monitor_loop())


@app.get("/healthz")
async def healthz():
    return {"ok": True, "partners": len(PARTNERS), "leads": len(LEADS), "assignments": len(ASSIGNMENTS)}


@app.post("/v1/partners")
async def upsert_partner(p: PartnerIn):
    pid = p.id or str(uuid.uuid4())
    last_active = p.last_active_at or now_utc()
    PARTNERS[pid] = Partner(
        id=pid,
        name=p.name,
        lat=p.lat,
        lng=p.lng,
        city=p.city,
        state=p.state,
        service_radius_km=p.service_radius_km,
        app_installed=p.app_installed,
        is_qualified=p.is_qualified,
        last_active_at=last_active,
        max_concurrent_open_leads=p.max_concurrent_open_leads,
        active_assigned_count=p.active_assigned_count,
        conv_rate_30d=p.conv_rate_30d,
        strikes_7d=p.strikes_7d,
        weekly_quota_target=p.weekly_quota_target,
        weekly_assigned_count=p.weekly_assigned_count,
    )
    return {"id": pid}


@app.get("/v1/partners")
async def list_partners():
    return [asdict(p) for p in PARTNERS.values()]


@app.post("/v1/leads")
async def ingest_lead(l: LeadIn):
    lid = l.id or str(uuid.uuid4())
    lead = Lead(id=lid, phone_number=l.phone_number, vehicle_number=l.vehicle_number, address=l.address)
    LEADS[lid] = lead
    await LEAD_QUEUE.put(lid)
    return {"id": lid, "queued": True}


@app.get("/v1/leads/{lead_id}")
async def get_lead(lead_id: str):
    ld = LEADS.get(lead_id)
    if not ld:
        raise HTTPException(404, "Lead not found")
    data = asdict(ld)
    data["assignments"] = [asdict(a) for a in ASSIGNMENTS if a.lead_id == lead_id]
    return data


@app.post("/v1/leads/{lead_id}/assign")
async def assign_now(lead_id: str):
    ld = LEADS.get(lead_id)
    if not ld:
        raise HTTPException(404, "Lead not found")
    primary, standby = match_partner(ld)
    if not primary:
        return {"assigned": False, "reason": "no-partner"}
    create_assignment(ld.id, primary.id, is_active=True, queue_rank=1)
    if standby:
        for i, p in enumerate(standby, start=2):
            create_assignment(ld.id, p.id, is_active=False, queue_rank=i)
    a = active_assignment_for_lead(ld.id)
    if a:
        a.notification_sent_at = now_utc()
    return {"assigned": True, "primary": primary.id, "standby": [p.id for p in standby]}


# UVicorn entry (optional)
if __name__ == "__main__":
    import uvicorn
    uvicorn.run("matching_service:app", host="0.0.0.0", port=8000, reload=False)
